# 프록시

엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.  
엔티티 조회 시 연관된 엔티티를 사용하지 않을 경우, 연관된 엔티티까지 함께 조회해 두는 것은 효율적이지 않다.

JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 **지연 로딩**이라 한다.  
연관된 엔티티가 실제로 사용되는 시점에 데이터베이스에서 연관된 데이터에 필요한 데이터를 조회한다.

지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 **프록시 객체**라고 한다.

> JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임했다. 하이버네이트는 지연 로딩을 지원하기 위해 프록시를 사용하는 방법과 바이트 코드를 수정하는 두 가자 방법을 제공한다.

## 프록시 기초

`em.find()`으로 직접 엔티티를 조회하면 연관된 엔티티를 실제 사용여부와 상관 없이 데이터베이스에서 조회하게 된다.

`em.getReference()`를 사용하면 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미룰 수 있다.  
해당 메서드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체를 생성하는 대신 데이터베이스 접근을 위임한 **프록시 객체**를 반환한다.

### 프록시 객체의 초기화

프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 엔티티 객체를 생성하는데 이것을 **프록시 객체 초기화**라고 한다.

1. 프록시 객체에 메소드를 호출해서(getter 메서드를 사용하는 등) 실제 데이터를 조회한다.
1. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라고 한다.
1. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
1. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 `target` 멤버 변수에 보관한다.
1. 프록시 객체는 실제 엔티티 객체의 메서드(1번에서 호출했던 메서드와 같은 이름의 메서드를)을 호출해서 결과를 반환한다.

### 프록시의 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 `em.getReference()`를 호출해도 프록시가 아닌 실제 엔티티를 반한한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다.

<!-- ### 준영속 상태와 초기화 -->

## 프록시와 식별자

엔티티를 프록시로 조회할 때 식별자의 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 저장한다.  
연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다. 참고로 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 설정해도 초기화하지 않는다.

# 즉시 로딩과 지연 로딩

- **즉시 로딩**(Eager Loading): 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. (`@ManyToone(fetch = FetchType.EAGER)`)
    - 연관된 엔티티를 즉시 조회한다. 가능하면 JOIN를 활용해서 한 번에 조회한다.
- **지연 로딩**:(Lazy Loading) 연관된 엔티티를 실제 사용할 때 조회한다. (`@ManyToone(fetch = FetchType.LAZY)`)
    - 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.

## JPA 기본 페치 전략

- 즉시 로딩(`FetchType.EAGER`): `@ManyToOne`, `@OneToOne`
    - 연관된 엔티티가 하나뿐인 경우 사용
    - 컬랙션을 로딩하는 것은 비용이 많이 들고 너무 많은 데이터를 로딩할 수 있기 때문에, 꼭 필요한 곳에서만 즉시 로딩을 사용하도록 최적화해야 한다.
- 지연 로딩(`FetchType.LAZY`): `@OneToMany`, `@ManyToMany`
    - 연관된 엔티티가 1개를 초과할 경우(컬랙션) 사용

### 컬랙션에 `FetchType.EAGER` 사용 시 주의사항

- **컬랙션을 하나 이상 즉시 로딩하는 것 권장하지 않음**
- **컬랙션 즉시 로딩은 항상 OUTER JOIN을 사용한다.**

- `@ManyToOne`, `@OneToOne`
    - `optional = false` : 내부 조인
    - `optional = true` : 외부 조인
- `@OneToMany`, `@ManyToMany`
    - `optional = false` : 외부 조인
    - `optional = true` : 외부 조인

# 영속성 전이(`CASCADE`)

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다. 따라서 부모 엔티티를 영속 상태로 만들고 자식 엔티티도 각각 영속 상태로 만든다.  
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 **영속성 전이** 기능을 사용하면 된다. (쉽게 말해 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.)

JPA는 `CASCADE` 옵션으로 영속성 전이를 제공한다.

## CASCADE의 종류

- **`cascade = CascadeType[]`의 종류**: 여러 속성을 같이 사용할 수 있다.
    - `CascadeType.ALL`: 모두 적용
    - `CascadeType.PERSIST`: 영속
    - `CascadeType.MERGE`: 병합
    - `CascadeType.REMOVE`: 삭제
    - `CascadeType.REFRESH`: REFRESH
    - `CascadeType.DETACH`: DETACH

# 고아 객체(`Orphan`)

JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 **고아 객체 제거**[^1]라고 한다.  
이 기능을 사용하면 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다. (`@OneToMany(orphanRemoval = true)`)

고아 객체 제거에는 기능이 하나 더 있는데, 개념적으로 볼 때 부모를 제거하면 자식은 고아가 된다.  
따라서 부모를 제거하면 자식도 같이 제거된다. (`CascadeType.REMOVE`를 설정하는 것과 동일하다.)

> 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.  
따라서 이 기능은 참조하는 곳이 하나일 때만 사용해야 한다. 만약 삭제한 엔티티가 다른 곳에서도 참조한다면 문제가 발생할 수 있다.  
이런 이유로 `orphanRemoval`는 `@OneToOne`이나 `@OneToMany`에서만 사용할 수 있다.

# 정리

- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기술을 사용한다.
- 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시 로딩, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라고 한다.
- 객체를 저장하거나 삭제할 때 연관된 객체도 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이라고 한다.
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용한다.