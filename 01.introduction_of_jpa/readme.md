# JPA

자바 진형의 ORM 기술 표준

- CRUD SQL 작성할 필요가 없고 조회된 결과를 객체로 매핑하는 작업을 대부분 자동으로 처리해준다.
- *네이티브 SQL* 기능을 사용하여 직접 SQL를 작성하거나 *데이터베이스 쿼리 힌트*를 사용하여 성능을 최적화 시킬 수 있다.
- 코드를 거의 수정하지 않고 다른 데이터베이스로 쉽게 변경할 수 있다.

## 마이바티스와 차이

Mybatis와 스프링 JdbcTemplate은 보통 SQL 매퍼라고 부른다. 이것은 이름 그대로 객체와 SQL을 매핑한다. SQL과 매핑할 객체만 지정하면 JDBC API 사용과 응답 결과를 객체로 매핑하는 일을 SQL 매퍼가 대신 처리해준다. 다만 SQL문을 직접 개발자가 작성해야 하므로 SQL에 의존하는 개발을 피할 수 없다. 반면 ORM은 객체와 테이블을 매핑만 하면 ORM 프레임워크가 SQL을 만들어 데이터베이스와 관련된 처리를 해주므로 SQL에 의존하는 개발을 피할 수 있다.

# SQL을 직접 다를 때 발생하는 문제점

- 진정한 의미의 계층 분할이 어렵다.
- 엔티티[^1]를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

[^1]: 비즈니스 요구사항을 모델링한 객체

# 패러다임의 불일치

비즈니스 요구사항을 정의한 도메인 모델을 객체로 모델링하면 객체지향 언어가 가진 장점들을 활용할 수 있다. 다만 이렇게 정의한 도메인 모델을 저장할 때 발생하는데 객체 인스턴스를 생성한 후에 메모리가 아닌 영구 보관 해야한다.

객체의 기능(메서드)은 클래스에 정의되어 있으므로 객체 인스턴스의 상태인 속성만 저장했다가 필요할 때 불러와서 복구하면 된다.

객체가 단순하면 객체의 속성 값을 파일이나 데이터베이스에 저장하면 되지만, 부모 객체를 상속 받았거나 다른 객체를 참조하고 있다면 객체의 상태를 저장하기 쉽지 않다.  
자바에서는 객체를 파일로 저장하는 직렬화 기능과 저장된 파일을 객체로 복구하는 역 직렬화 기능을 지원하지만 직렬화된 객체를 검색하기 어렵다.  
현실적인 대안은 관계형 데이터베이스에 저장하는 것인데, 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 그리고 추상화, 상속, 다형성와 같은 개념이 없다.  
객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 기능과 표현 방법도 다르다. 이것이 이 둘의 패러다임의 불일치를 이르킨다. 따라서 객체 구조를 테이블 구조에 저장하는 데 한계가 있다.

문제는 이런 객체와 관계형 데이터베이스 간의 패러다임 불일치 문제를 해결하는 데 너무 많은 시간과 코드를 소비하는 데 있다.

## 상속

객체는 상속 기능이 존재하지만 테이블은 그렇지 않다. 그나마 데이터베이스 모델링에서 슈퍼타입, 서브타입 관계를 사용하면 객체의 상속과 가장 유사한 형태로 테이블을 설계할 수 있다.

## 연관관계

객체는 참조를 사용하여 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.  
반면 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.

객체와 관계형 데이터베이스 간 패러다임 불일치는 객체지향 모델링을 거의 포기하게 만들 정도로 극복하기 어려운 문제이다.

관계형 데이터베이스는 조인이라는 기능이 있어 외래 키의 값(FK)을 그대로 보관해도 되지만, 객체는 연관된 객체의 참조를 보관해야만 한다.

## 객체지향 모델링

객체는 연관된 객체를 보관할 때 외래 키를 사용하지 않고 연관된 객체의 참조를 저장해야 한다. 그런데 이처럼 객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기란 쉽지 않다.  
객체 모델은 외래 키가 필요 없고 단지 연관된 객체의 참조만 있으면 된다. 반면 테이블은 참조가 필요 없고 외래 키(FK)만 있으면 된다.

결국 개발자가 중간에서 변환 역할을 해야한다.

## 객체 그래프 탐색

객체에서 연관된 객체의 조회할 때는 참조를 사용해서 연관된 객체를 찾는데, 이것을 **객체 그래프 탐색**이라고 한다.

객체는 마음껏 객체 그래프를 탐색할 수 있어야 하는데, SQL을 직접 다루면 처음 실행한 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는 지가 정해져 버린다.  
이것은 객체지향 개발자에게 큰 제약으로 다가온다. 왜냐하면 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제 끊어질 지 모를 객체 그래프를 함부로 탐색할 수 없기 떄문이다.

특정 객체를 조회했을 때, 이 객체와 연관된 객체의 방향으로 객체 그래프를 탐색할 수 있는 지 없는 지를 당장 예측할 수 없다. 결국 어디까지 객체 그래프 탐색이 가능한 지 알아보려면 DAO(데이터 접근 계층)를 열어서 SQL을 직접 확인해야 한다.

엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제이다.

## JPA와 객체 그래프 탐색

JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT문을 실행한다. 따라서 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 **지연로딩**이라고 부른다.

조회한 객체와 조회한 객체와 연관된 객체를 함께 사용하려고 할 때, 각각 한 테이블씩 조회하는 것보다 객체를 조회한 시점에 SQL 조인(SELECT JOIN)을 사용해서 조회한 객체와 연관된 객체를 함께 조회하는 것이 효과적이다.

JPA는 연관된 객체를 즉시 함께 조회할지, 실제 사용되는 시점에 지연해서 조회할지를 간단한 설정으로 정의할 수 있다.

## 비교

데이터베이스는 기본 키의 값으로 각 Row를 구분한다. 반면 객체는 동일성 비교와 동등성 비교 두 가지 비교 방법이 있다.

- 동일성 비교(`==`): 객체 인스턴스의 주소 값을 비교
- 동등성 비교(`equlas()`): 메서드를 사용해서 객체 내부의 값을 비교

같은 데이터베이스의 Row에서 두 번 조회했을 때, 같은 Row에 조회한 두 객체간 동일성 비교를 하면 `false`이다. 객체 측면에서는 서로 다른 인스턴스이기 때문이다.(만약 객체를 컬렉션에 보관했다면 동일성 비교은 성공했을 것이다.)

반면 JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것으로 보장된다.(두 객체간 동일성 비교 `true`)

# JPA란

- ORM(Object Relational Mapping): 객체와 관계형 데이터베이스를 매핑한다는 뜻
- JPA(Java Persistence API): 자바 진형 ORM 기술에 대한 API 표준 명세이다.(관련 인터페이스를 모와둔 것)
- 하이버네이트: 자바 진형에 다양한 ORM 프레임워크들 중 하나로, 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크이다.

ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐 아니라 객체와 테이블을 매핑해서 패러다임의 불일치를 개발자 대신 해결해준다.  
따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다.

JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다는 장점이 있다. 그리고 JPA 표준은 일반적이고 공통적인 기능의 모음이다.

## JPA를 사용하는 이유

### 생산성

JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다. 따라서 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 되고, DDL 문을 자동으로 생성해주는 기능도 있다. 이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전 시킬 수 있다.

### 유지보수

SQL 직접 다루면 엔티티에 필드 하나면 수정해도 관련된 SQL문과 JDBC API 코드를 모두 변경해야만 했다. 반면 JPA는 개발자가 작성해야 했던 SQL문과 JDBC API 코드를 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다.
패러다임의 불일치 해결: JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임 불일치 문제를 해결해준다.

### 성능
JPA는 애플리케이션과 데이터 베이스 사이에서 다양한 성능 최적화 기회를 제공한다. 또한 SQL 힌트를 넣을 수 있는 기능도 제공한다. 또한 네이티브 SQL 기능을 사용해서 직접 SQL을 호출하는 것도 가능하다.

### 데이터 접근 추상화와 벤더 독립성

관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많은데(페이징 처리 등) 데이터베이스마다 달라서 사용법을 각각 배워야 한다. 결국 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기 매우 어렵다. JPA는 애플케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.

### 표준

JPA는 자바 진영의 ORM 기술 표준이다. 표준을 사용하면 다른 구현 기술로 손 쉽게 변경할 수 있다.